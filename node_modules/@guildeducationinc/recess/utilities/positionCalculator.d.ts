/**
 * Enum to represent outside alignment positions of content relative to a target.
 * The name is broken down to represent `{side}{alignment}`
 */
/**
 * Middle alignments align the center of the content to the center of the target
 */
/**
 * Top alignments align the top of the content to the top of the target
 */
/**
 * Bottom alignments align the bottom of the content to the bottom of the target
 */
/**
 * Right alignments align the right side of the content to the right of the target
 */
/**
 * Left alignments align the left side of the content to the left of the target
 */
export declare enum AlignmentPositions {
    topLeft = "topLeft",
    topMiddle = "topMiddle",
    topRight = "topRight",
    rightTop = "rightTop",
    rightMiddle = "rightMiddle",
    rightBottom = "rightBottom",
    bottomRight = "bottomRight",
    bottomMiddle = "bottomMiddle",
    bottomLeft = "bottomLeft",
    leftBottom = "leftBottom",
    leftMiddle = "leftMiddle",
    leftTop = "leftTop"
}
export interface PositionSolution {
    position: ClientRect;
    positionName: AlignmentPositions;
}
/**
 * The main public facing API exposed to consumers. It find the best solution by finding the  largest
 * area solution based on preferred positions of the content realtive to the target
 *
 * translatePosition is a optional callback that is primarly used for adding spacing to the  positioning solution
 * For example, without any translation, the content and the  target are touching. However, in real world designs, there
 * is typically space between the target and the content. This spacing can be added after the fact by adding margins or
 * adjusting the position of the target. However, by doing this after the correct position is found means that the
 * position may actually not be optimal because this spacing was not taken into account in the intital calcualtion.
 * This function serves as a means to translate the target BEFORE any positioning calcuation is done, meaning that
 * the solution that is found takes into account any padding/spacing around the target/content that may be desired.
 *
 * A real world example of this is our popover and tooltip. Both have target/conten spacing of 4px PLUS the height
 *  of the the arrow (12px). In this case, we want to translate the content by 16px before the position is calculated
 * so that we take into account this extra padding
 */
declare const getPosition: (target: ClientRect, content: ClientRect, container: ClientRect, positions?: AlignmentPositions[], translatePosition?: (position: AlignmentPositions, target: ClientRect) => ClientRect) => PositionSolution;
/**
 * element.getBoundingClientRect() returns top and left coordinates relative to the viewport.
 * (equavalent to clientX, clientY)
 * To be able to use css `position: absolute`, we need to translate those coordinates to be
 * relative to the HTML document (pageX, pageY). One advantage of this is that is we position
 * the content relative to the page, then the content will move with the target if the page scrolls.
 *
 * This method is a translation between clientX/Y and pageX/Y
 */
export declare const mapPositionToPage: (solution: ClientRect) => {
    top: number;
    bottom: number;
    right: number;
    left: number;
    height: number;
    width: number;
};
export { getPosition };
