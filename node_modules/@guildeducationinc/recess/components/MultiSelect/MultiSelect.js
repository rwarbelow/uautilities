var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/* eslint-disable jsx-a11y/click-events-have-key-events */
/* eslint-disable jsx-a11y/no-static-element-interactions */
import * as React from 'react';
import * as styles from './index.module.css.js';
import Panel from '../Panel';
import { AlignmentPositions } from '../../utilities/positionCalculator';
import classnames from '../../utilities/classnames';
import { Keys } from '../../utilities/keyboard';
import ClickOutside from '../ClickOutside';
import { MultiSelectPanel } from './MultiSelectPanel';
import { MultiSelectList } from './MultiSelectList';
import { ArrowDropDown, ArrowDropUp, ChevronDown, ChevronUp, InfoCircle } from '../Icons';
import { includes } from 'lodash';
import { Tooltip } from '../Tooltip';
var DropdownMargin = 4;
var MultiSelect = /** @class */ (function (_super) {
    __extends(MultiSelect, _super);
    function MultiSelect(props) {
        var _this = _super.call(this, props) || this;
        _this.componentDidMount = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.optionsSetup(this.props.options)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.updateViewableOptions()];
                    case 2:
                        _a.sent();
                        if (!this.state.minTriggerWidth && this.triggerRef.current) {
                            this.setState({
                                minTriggerWidth: this.triggerRef.current.getBoundingClientRect().width,
                            });
                        }
                        this.props.defaultOpen && this.props.noPanel && this.setState({ open: true });
                        return [2 /*return*/];
                }
            });
        }); };
        _this.UNSAFE_componentWillReceiveProps = function (nextProps) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(nextProps.options.length !== this.props.options.length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.optionsSetup(nextProps.options)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.updateViewableOptions()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.setState({
                                focusedIndex: this.defaultFocusState(),
                            })];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        }); };
        _this.optionsSetup = function (options) {
            // Maps all options/suboptions for keyboard actions and adds key to
            // parent subOption (subOptionsOpen: true|false)
            // and adds a child key mapping them to their parent
            var all = [];
            options.map(function (op) {
                if (!op.options) {
                    all = all.concat(op);
                }
                else {
                    all = all.concat(__assign(__assign({}, op), { subOptionsOpen: false }));
                    op.options.map(function (o) {
                        var updated = __assign(__assign({}, o), { subkey: op.value });
                        all = all.concat(updated);
                    });
                }
            });
            _this.setState({ allOptions: all });
        };
        _this.updateAllOptions = function (key, open) { return __awaiter(_this, void 0, void 0, function () {
            var updated;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        updated = this.state.allOptions.map(function (option) {
                            if (option.value === key) {
                                option.subOptionsOpen = open;
                            }
                            return option;
                        });
                        return [4 /*yield*/, this.setState({ allOptions: updated })];
                    case 1:
                        _a.sent();
                        this.updateViewableOptions();
                        return [2 /*return*/];
                }
            });
        }); };
        _this.updateOptionsOnClose = function () { return __awaiter(_this, void 0, void 0, function () {
            var updated;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        updated = this.state.allOptions.map(function (option) {
                            if (option.subOptionsOpen) {
                                option.subOptionsOpen = false;
                            }
                            return option;
                        });
                        return [4 /*yield*/, this.setState({ allOptions: updated })];
                    case 1:
                        _a.sent();
                        this.updateViewableOptions();
                        return [2 /*return*/];
                }
            });
        }); };
        _this.updateViewableOptions = function () {
            var allOptions = _this.state.allOptions;
            var inactive = [];
            allOptions.map(function (opt) {
                if (opt.subOptionsOpen === false) {
                    inactive.push(opt.value);
                }
            });
            var viewable = allOptions.filter(function (item) {
                return !includes(inactive, item.subkey);
            });
            _this.setState({ viewableOptions: viewable });
        };
        _this.handleOptionToggle = function (optionChanged) {
            var isArray = Array.isArray(optionChanged);
            if (isArray) {
                var optionsArray_1 = [];
                optionChanged.map(function (option) {
                    optionsArray_1 = optionsArray_1.concat(option.value);
                });
            }
        };
        _this.defaultFocusState = function () {
            var _a = _this.props, options = _a.options, selectedValues = _a.selectedValues;
            var focused = options.findIndex(function (_a) {
                var value = _a.value;
                return selectedValues.indexOf(value) > -1;
            });
            if (focused < 0) {
                focused = options.findIndex(function (option) { return !option.disabled; });
            }
            _this.state && _this.setFocusOption(_this.props.options[focused].value);
            return focused;
        };
        _this.incrementFocus = function () {
            var newIndex = (_this.state.focusedIndex + 1) % _this.state.viewableOptions.length;
            _this.setFocusOption(_this.state.viewableOptions[newIndex].value);
            _this.setFocus(newIndex);
        };
        _this.decrementFocus = function () {
            var calculatedIndex = _this.state.focusedIndex - 1;
            var newIndex = calculatedIndex < 0 ? calculatedIndex + _this.state.viewableOptions.length : calculatedIndex;
            _this.setFocusOption(_this.state.viewableOptions[newIndex].value);
            _this.setFocus(newIndex);
        };
        _this.handleKeyboardNav = function (e) {
            switch (e.key) {
                case Keys.ArrowUp:
                    _this.decrementFocus();
                    break;
                case Keys.ArrowDown:
                    _this.incrementFocus();
                    break;
                case Keys.Escape:
                    _this.closeList();
            }
        };
        _this.handleChange = function (_a) {
            var checked = _a.checked, option = _a.option, batched = _a.batched;
            _this.handleOptionToggle(option);
            var updatedValue = batched || option.value;
            _this.setFocusOption(updatedValue);
            var updatedIndex = _this.state.viewableOptions.findIndex(function (_a) {
                var value = _a.value;
                return value === updatedValue;
            });
            _this.setFocus(updatedIndex > -1 ? updatedIndex : 0);
            _this.props.onOptionChange({ optionChanged: option, checked: checked });
        };
        _this.setFocus = function (index) {
            _this.setState({ focusedIndex: index });
        };
        _this.setFocusOption = function (value) {
            _this.setState({ focusedOption: value });
        };
        _this.toggle = function () {
            /**
             * If we are toggling and the current state is not open, then we
             * are opening and shoudl reset the default focus state.
             */
            var nextOpenState = !_this.state.open;
            if (nextOpenState) {
                var focusedIndex = _this.defaultFocusState();
                _this.setState({
                    focusedIndex: focusedIndex,
                });
            }
            if (typeof _this.props.onToggle !== 'undefined') {
                _this.props.onToggle(nextOpenState);
            }
            _this.setState({ open: nextOpenState });
        };
        _this.focusTrigger = function () { return _this.triggerRef.current && _this.triggerRef.current.focus(); };
        _this.onListClose = function () {
            _this.focusTrigger();
        };
        _this.closeList = function () {
            _this.setState({ open: false });
            _this.updateOptionsOnClose();
            _this.focusTrigger();
        };
        _this.triggerRef = React.createRef();
        var defaultOption = _this.props.options.length ? _this.props.options[0].value : null;
        var selectedValue = _this.props.selectedValues.length ? _this.props.selectedValues[0] : null;
        _this.state = {
            minTriggerWidth: null,
            open: false,
            focusedIndex: _this.defaultFocusState(),
            allOptions: [],
            focusedOption: defaultOption || selectedValue,
            viewableOptions: [],
        };
        return _this;
    }
    MultiSelect.prototype.render = function () {
        var _a, _b, _c, _d;
        var _e;
        var formattedTestId = this.props.testid.replace(/-|\s/g, '');
        var labelId = this.props.label && formattedTestId + "-Label";
        var buttonId = formattedTestId + "-Trigger";
        var tooltipId = this.props.additionalInfo && ((_e = this.props.label) === null || _e === void 0 ? void 0 : _e.replace(' ', '-').toLowerCase()) + "-info";
        var ButtonAriaAttrs = {
            'aria-haspopup': 'listbox',
            'aria-expanded': this.state.open,
            'aria-owns': formattedTestId + "-DropdownContent",
            'aria-controls': formattedTestId + "-DropdownContent",
            'aria-disabled': this.props.disabled || false,
            'aria-labelledby': labelId + " " + buttonId,
        };
        var showList = this.state.open && !this.props.disabled;
        var classes = classnames(styles.dropdownTrigger, (_a = {},
            _a[styles.disabled] = this.props.disabled,
            _a[styles.focusedDropdownTrigger] = this.state.open,
            _a[styles.open] = this.state.open,
            _a));
        var PanelContent = MultiSelectPanel(MultiSelectList);
        var panelProps = {
            allOptions: this.state.allOptions,
            closeList: this.closeList,
            focusedIndex: this.state.focusedIndex,
            focusedOption: this.state.focusedOption,
            getOptionLabel: this.props.getOptionLabel,
            handleKeyboardNav: this.handleKeyboardNav,
            isOptionDisabled: this.props.isOptionDisabled,
            label: this.props.hideLabel && this.props.label,
            labelId: !this.props.hideLabel && labelId,
            onListClose: this.onListClose,
            onOptionChange: this.props.onOptionChange,
            options: this.props.options,
            selectedValues: this.props.selectedValues,
            toggleChecked: this.handleChange,
            updateAllOptions: this.updateAllOptions,
            additionalInfo: 'yo',
        };
        if (this.props.noPanel) {
            return (React.createElement(React.Fragment, null,
                React.createElement("button", __assign({ className: styles.noPanelLabelWrapper, id: buttonId, onClick: this.toggle }, ButtonAriaAttrs),
                    React.createElement("span", { className: classnames('text-blue fontWeight--600', (_b = {},
                            _b[styles.disabled] = this.props.disabled,
                            _b)) }, this.props.placeholder),
                    showList ? (React.createElement(ChevronUp, { size: 24, color: '#01a8a5' })) : (React.createElement(ChevronDown, { size: 24, color: this.props.disabled ? '#b2b2b2' : '#595959' }))),
                showList && (React.createElement("div", { className: classnames('margin--left_16 margin--right_16', styles.fadeIn) },
                    React.createElement(MultiSelectList, __assign({}, panelProps))))));
        }
        return (React.createElement(ClickOutside, { onOutsideClick: this.closeList, active: this.state.open, container: this.triggerRef.current },
            !this.props.hideLabel && (React.createElement("div", { className: styles.labelWrapper },
                React.createElement("span", { className: styles.label, id: labelId }, this.props.label),
                this.props.additionalInfo && (React.createElement(Tooltip, { TooltipContent: this.props.additionalInfo, id: tooltipId, preferredPositions: [AlignmentPositions.topMiddle] },
                    React.createElement(InfoCircle, { size: 24, "aria-label": 'More info' }))))),
            React.createElement("button", __assign({ onClick: this.toggle, ref: this.triggerRef, "data-testid": this.props.testid, className: classes, disabled: this.props.disabled, style: {
                    minWidth: this.props.minTriggerWidth,
                }, id: buttonId }, ButtonAriaAttrs),
                React.createElement("span", { "aria-hidden": !!this.props.selectedValues.length, className: styles.placeholder }, this.props.placeholder),
                React.createElement("span", { className: styles.hiddenValue }, this.props.selectedValues.join(', ')),
                showList ? (React.createElement(ArrowDropUp, { size: 16, className: classnames((_c = {},
                        _c[styles.openArrow] = this.state.open,
                        _c[styles.disabled] = this.props.disabled,
                        _c)) })) : (React.createElement(ArrowDropDown, { size: 16, className: classnames((_d = {}, _d[styles.disabled] = this.props.disabled, _d)) }))),
            React.createElement(Panel, { show: showList, target: this.triggerRef.current, PanelContent: PanelContent, panelProps: panelProps, ariaId: ButtonAriaAttrs['aria-owns'], preferredPositions: [AlignmentPositions.bottomLeft], contentSize: {
                    minWidth: Math.max(this.props.minContentWidth || this.state.minTriggerWidth, this.state.minTriggerWidth),
                }, panelMargin: DropdownMargin, testid: this.props.testid + "--multiSelect" })));
    };
    return MultiSelect;
}(React.PureComponent));
export { MultiSelect };
