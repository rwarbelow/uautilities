import * as React from 'react';
export interface Option {
    /**
     * If the selection was batched (select all from submenu checkbox) in a group make the parent the focused item
     */
    batched?: string | number;
    disabled?: boolean;
    label: string;
    options?: Option[];
    subOptionsOpen?: boolean;
    subkey?: string | number;
    value: string | number;
}
export interface DropdownProps {
    /**
     * Defaults to open (for mobile) if passed along with the 'noPanel' prop
     *
     * @default false
     */
    defaultOpen?: boolean;
    /**
     * Boolean to determine if the dropover is disabled and not interactable
     *
     * @default false
     */
    disabled?: boolean;
    /**
     * Optional prop that allows for the dynamic calculation of
     * an options label.
     * This is useful for cases when the option label may be computed
     * based on some other type of application data, such as data from an
     * external API.
     *
     * This is the more performant way to handle a dynamic label, otherwise
     * the options will need to be recomputed each time any label changes, which
     * could result in extra renders
     *
     * `getOptionLabel` overrides `option.label` value if it's present
     */
    getOptionLabel?: (option: Option) => string;
    /**
     * Additional information that is displayed in a tooltip next to the input label.
     */
    additionalInfo?: React.ComponentType | string;
    /**
     * In the event that you don't want a label rendered, set `hideLabel` to true.
     * You should still provide a value for `label` for optimal accessibility.
     *
     * @default false
     */
    hideLabel?: boolean;
    /**
     * Optional prop that allows for the dynamic calculation of
     * if an option is disabled.
     * This is useful for cases when the option may be disabled based on
     * some othe application state, for instance an external API.
     *
     * This is the more performant way to handle a dynamic disabling, otherwise
     * the options will need to be recomputed each time any label changes, which
     * could result in extra renders
     *
     * Overrides the default `option.disabled`
     */
    isOptionDisabled?: (option: Option) => boolean;
    /**
     * Label for MultiSelect input. This value should always be provided for optimal
     * accessibility. You can use the `hideLabel` prop if you do not want label rendered.
     */
    label?: string;
    /**
     * Enforces a minimum width on the multiselect dropdown content
     */
    minContentWidth?: number;
    /**
     * Enforces a minimum width on the multiselect trigger button
     *
     * @default unset
     */
    minTriggerWidth?: number;
    /**
     * removes the Panel wrapper and just renders the MultiSelectList (ex: on mobile)
     */
    noPanel?: boolean;
    /**
     * Handler called when an option has been toggled
     */
    onOptionChange: (changeArgs: {
        optionChanged: Option | Option[];
        checked: boolean;
    }) => void;
    /**
     * Label for the dropdown trigger
     */
    /**
     * Hook to be called when the multiselect toggles open or closed. Meant to be used for things like
     * analytics or any other logic that may need to happen when the dropdown opens or closes
     */
    onToggle?: (open?: boolean) => void;
    /**
     * A list selectable options
     */
    options: Option[];
    /**
     * This will always be displayed as the value in the dropdown trigger/button
     */
    placeholder: string;
    /**
     * Array of option values that are selected
     */
    selectedValues: (string | number)[];
    /**
     * TestID for automation. This also drives aria ids. This needs to exist and must be unique
     */
    testid: string;
}
interface MultiselectState {
    allOptions: Option[];
    focusedIndex: number;
    focusedOption: string | number;
    minTriggerWidth: number | null;
    open: boolean;
    viewableOptions: Option[];
}
export declare class MultiSelect extends React.PureComponent<DropdownProps, MultiselectState> {
    private triggerRef;
    constructor(props: DropdownProps);
    componentDidMount: () => Promise<void>;
    UNSAFE_componentWillReceiveProps: (nextProps: any) => Promise<void>;
    private optionsSetup;
    updateAllOptions: (key: string | number, open: boolean) => Promise<void>;
    updateOptionsOnClose: () => Promise<void>;
    updateViewableOptions: () => void;
    private handleOptionToggle;
    private defaultFocusState;
    private incrementFocus;
    private decrementFocus;
    private handleKeyboardNav;
    private handleChange;
    private setFocus;
    private setFocusOption;
    private toggle;
    private focusTrigger;
    private onListClose;
    private closeList;
    render(): JSX.Element;
}
export {};
