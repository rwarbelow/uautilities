import * as React from 'react';
import { AlignmentPositions } from '../../utilities/positionCalculator';
export declare type TargetMoveReason = 'targetScroll' | 'windowResize';
export interface ContentSizing {
    minWidth?: number;
    maxWidth?: number;
    minHeight?: number;
    maxHeight?: number;
}
export interface TranslationDelta {
    originOffset: number;
    getDirection: (position: AlignmentPositions) => number;
}
export interface Translation {
    deltaY?: TranslationDelta;
    deltaX?: TranslationDelta;
}
export interface BasePanelProps {
    positionStyles: React.CSSProperties;
    arrowPosition: string;
    positionName: string;
    targetPosition: ClientRect;
    ariaId: string;
    show: boolean;
    target: Element | null;
    testid: string;
}
export interface PanelProps<T> {
    /**
     * Boolean to determine if the panel is current visible
     */
    show: boolean;
    /**
     * A reference to the target that the panel will be positioned around
     */
    target: Element | null;
    /**
     * A react component to render the content of the panel.
     * PanelContent is constructed via the `PanelContentWrapperFactory` method to
     * abstract away general panel styles and set up the necssary forwardRefs.
     */
    PanelContent: React.ForwardRefExoticComponent<T>;
    /**
     * A array of preferred alignment positions for the panel content relative to the target.
     * If nothing is passed, it defaults to `topLeft` and moves in a clockwise direction
     */
    /**
     * User specific props to pass to the Panel Content
     */
    panelProps: T;
    preferredPositions?: AlignmentPositions[];
    /**
     * Callback for handeling the case of when the panel moves either via scroll or window resize
     */
    onTargetMove?: (reason: TargetMoveReason) => void;
    /**
     * Optional id that links the panel to it's trigger via the `aria-owns` and `aria-controls` attribute
     */
    ariaId?: string;
    /**
     * Object for setting restrictions on the panels size
     */
    contentSize?: ContentSizing;
    /**
     * Panel margin relative to it's target
     */
    panelMargin?: number;
    role?: string;
    /**
     * ID for selecting a panel via automation
     */
    testid?: string;
    /**
     *
     */
    translation?: Translation;
}
interface PanelState {
    /**
     * Tracked styles for the panel that include things like it's position
     * relative to the target and max/min height/width.
     *
     * Both `contentStyles` and `position` are recalculated in the following cases
     * 1. The panel is toggled from `show = false` to `show = true`
     * 2. The window is resized (It's assumed the target moves and therefore the position must be recalculated)
     * 3. The target is scrolled.
     */
    contentStyles: React.CSSProperties;
    /**
     * Current position of the panel relative to it's trigger. This is recalculated each time `calculatePosition` is called
     */
    position: AlignmentPositions | null;
    maxHeight: number;
    maxWidth: number;
    /**
     * Boolean to track the visibility of the target on the page.
     * `true` if the trigger is within the visible viewport.
     * `false` if the trigger is outside the visible viewport.
     */
    visible: boolean;
}
/**
 * Panel is an internal component that combines the Portal and position helper
 * to render content near a target. It handles the logic around
 * attaching the event handlers, calculating the position of content, and updating
 * the position of the content when the target moves due to a window resize
 *
 * Generally used as a composable component used interally by recess, if you need
 * to use `Panel` for a custom component, see `Tooltip`, `Popover`, and `Dropdown`
 * for examples of how to use.
 */
export declare class Panel<P> extends React.PureComponent<PanelProps<P>, PanelState> {
    private content;
    private debouncedResizeUpdate;
    private debouncedScrollUpdate;
    private scrollParent;
    constructor(props: PanelProps<P>);
    componentDidUpdate(prevProps: PanelProps<P>): void;
    componentWillUnmount(): void;
    private calculateInitialPosition;
    private calculatePosition;
    private onWindowResize;
    private setupScrollListener;
    private onScroll;
    private updatePositionAfterMove;
    render(): JSX.Element;
}
export {};
